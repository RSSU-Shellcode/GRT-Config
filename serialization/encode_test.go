package serialization

import (
	"testing"

	"github.com/davecgh/go-spew/spew"
	"github.com/stretchr/testify/require"
)

func TestMarshal(t *testing.T) {
	t.Run("common", func(t *testing.T) {
		s1 := testStruct{
			arg1: 123,
			arg2: [2]uint32{456, 789},
			arg3: nil,
			arg4: "",
			arg5: 0x19,
			arg6: 0x1548,
			arg7: 0x123,
			arg8: "hello",
			arg9: []byte{0x12, 0x34},

			arg10: 0x12,
			arg11: 0x1234,
			arg12: -0x12345678,
			arg13: -0x1234567812345678,
			arg14: 0x12,
			arg15: 0x1234,
			arg16: 0x12345678,
			arg17: 0x1234567812345678,
			arg18: 0.1234,
			arg19: 0.123459664,
			arg20: true,

			arg26: [2]uint16{0x1234, 0x5678},
			arg37: []uint16{0x5678, 0x1234},

			arg42: []bool{true, false},
		}
		data, err := Marshal(&s1)
		require.NoError(t, err)
		spew.Dump(data)

		expected := []byte{
			0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00,
			0x08, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80,
			0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
			0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
			0x0C, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x80,
			0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
			0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
			0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
			0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x80,
			0x04, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00, 0x80,
			0x10, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x80,
			0x04, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00, 0x80,
			0x10, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00, 0x80,
			0x10, 0x00, 0x00, 0x80, 0x02, 0x00, 0x00, 0x80,
			0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80,
			0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80,
			0x00, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x80,
			0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80,
			0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80,
			0x02, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
			0x7B, 0x00, 0x00, 0x00, 0xC8, 0x01, 0x00, 0x00,
			0x15, 0x03, 0x00, 0x00, 0x19, 0x48, 0x15, 0x68,
			0x00, 0x65, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x6F,
			0x00, 0x00, 0x00, 0x12, 0x34, 0x12, 0x34, 0x12,
			0x88, 0xA9, 0xCB, 0xED, 0x88, 0xA9, 0xCB, 0xED,
			0x87, 0xA9, 0xCB, 0xED, 0x12, 0x34, 0x12, 0x78,
			0x56, 0x34, 0x12, 0x78, 0x56, 0x34, 0x12, 0x78,
			0x56, 0x34, 0x12, 0x24, 0xB9, 0xFC, 0x3D, 0x6A,
			0x51, 0x41, 0x73, 0x0D, 0x9B, 0xBF, 0x3F, 0x01,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x34, 0x12, 0x78, 0x56, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x56,
			0x34, 0x12, 0x01, 0x00,
		}
		require.Equal(t, expected, data)
	})

	t.Run("nil pointer", func(t *testing.T) {
		var p *int
		data, err := Marshal(p)
		require.EqualError(t, err, "value is a nil pointer")
		require.Nil(t, data)
	})

	t.Run("not struct", func(t *testing.T) {
		data, err := Marshal(123)
		require.EqualError(t, err, "value must be a struct or pointer to struct")
		require.Nil(t, data)
	})

	t.Run("invalid field type", func(t *testing.T) {
		s := struct {
			arg1 chan int
		}{}
		data, err := Marshal(&s)
		require.EqualError(t, err, "field type of chan is not support")
		require.Nil(t, data)
	})

	t.Run("invalid array element type", func(t *testing.T) {
		s := struct {
			arg1 [2]chan int
		}{}
		data, err := Marshal(&s)
		require.EqualError(t, err, "element type of chan is not support")
		require.Nil(t, data)
	})

	t.Run("invalid slice element type", func(t *testing.T) {
		s := struct {
			arg1 []chan int
		}{
			arg1: make([]chan int, 1),
		}
		data, err := Marshal(&s)
		require.EqualError(t, err, "element type of chan is not support")
		require.Nil(t, data)
	})
}
